// Generated by Fibre Channel protocol generator
// Any manual changes will be lost

package fibrechannel

import (
	"bytes"
	"fmt"
	"io"

	"github.com/bluecmd/fibrechannel/els"
	"github.com/bluecmd/fibrechannel/encoding"
)

var _ = bytes.NewReader

const (
	EOFn   = 0x1 // TODO
	EOFt   = 0x2 // TODO
	EOFrt  = 0x3 // TODO
	EOFdt  = 0x4 // TODO
	EOFni  = 0x5 // TODO
	EOFdti = 0x6 // TODO
	EOFrti = 0x7 // TODO
	EOFa   = 0x8 // TODO

	SOFf  = 0x1 // TODO
	SOFi4 = 0x2 // TODO
	SOFi2 = 0x3 // TODO
	SOFi3 = 0x4 // TODO
	SOFn4 = 0x5 // TODO
	SOFn2 = 0x6 // TODO
	SOFn3 = 0x7 // TODO
	SOFc4 = 0x8 // TODO

	TypeBLS      = 0x0  // TODO
	TypeELS      = 0x1  // TODO
	TypeLLCSNAP  = 0x4  // TODO
	TypeIP       = 0x5  // TODO
	TypeFCP      = 0x8  // TODO
	TypeGPP      = 0x9  // TODO
	TypeSBToCU   = 0x1b // FICON / FC-SB-3: Control Unit -> Channel
	TypeSBFromCU = 0x1c // FICON / FC-SB-3: Channel -> Control Unit
	TypeFCCT     = 0x20 // TODO
	TypeSWILS    = 0x22 // TODO
	TypeAL       = 0x23 // TODO
	TypeSNMP     = 0x24 // TODO
	TypeNVME     = 0x28 // TODO
	TypeSPINFAB  = 0xee // TODO
	TypeDIAG     = 0xef // TODO
)

type CSCtl struct {
	Data uint8
}

type EOF uint8

type Frame struct {
	RCtl          uint8
	DestinationID [3]byte
	CsctlPriority interface{}
	SourceID      [3]byte
	fcType        Type
	FCtl          FrameControl
	SeqID         uint8
	DFCtl         uint8
	SeqCount      uint16
	OXID          uint16
	RXID          uint16
	Parameters    [4]byte
	Payload       interface{}
}

type FrameControl struct {
	TODO1          int
	PriorityEnable bool
	TODO2          int
}

type Prio struct {
	Data uint8
}

type SOF uint8

type Type uint8

func (o *CSCtl) ReadFrom(r io.Reader) (int64, error) {
	_io := encoding.Reader{R: r}
	fixup := []func() (int64, error){}
	_io.ReadObject(&o.Data)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	for _, f := range fixup {
		if _, err := f(); err != nil {
			return _io.Pos, err
		}
	}
	return _io.Pos, nil
}

func (o *CSCtl) WriteTo(w io.Writer) (int64, error) {
	_io := encoding.Writer{W: w}
	_io.WriteObject(o.Data)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	return _io.Pos, nil
}

func (o *EOF) String() string {
	switch *o {
	case 0x1:
		return "EOFn <0x1> (TODO)"
	case 0x2:
		return "EOFt <0x2> (TODO)"
	case 0x3:
		return "EOFrt <0x3> (TODO)"
	case 0x4:
		return "EOFdt <0x4> (TODO)"
	case 0x5:
		return "EOFni <0x5> (TODO)"
	case 0x6:
		return "EOFdti <0x6> (TODO)"
	case 0x7:
		return "EOFrti <0x7> (TODO)"
	case 0x8:
		return "EOFa <0x8> (TODO)"
	default:
		return fmt.Sprintf("--Invalid Enum Value-- <0x%x>", *o)
	}
}

func (o *Frame) ReadFrom(r io.Reader) (int64, error) {
	_io := encoding.Reader{R: r}
	fixup := []func() (int64, error){}
	_io.ReadObject(&o.RCtl)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.ReadObject(&o.DestinationID)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	var __o_CsctlPriority_CsctlPriority [1]byte
	_io.Read(__o_CsctlPriority_CsctlPriority[:])
	fixup = append(fixup, func() (int64, error) {
		_io := encoding.Reader{R: bytes.NewReader(__o_CsctlPriority_CsctlPriority[:])}
		switch o.FCtl.PriorityEnable {
		case false:
			i := &CSCtl{}
			if n, err := i.ReadFrom(&_io); err != nil {
				return n, err
			}
			o.CsctlPriority = i
		case true:
			i := &Prio{}
			if n, err := i.ReadFrom(&_io); err != nil {
				return n, err
			}
			o.CsctlPriority = i
		}
		return 1, nil
	})

	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.ReadObject(&o.SourceID)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.ReadObject(&o.fcType)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	{
		var bs [3]byte
		_io.Read(bs[:])
		if _io.Error != nil {
			return _io.Pos, _io.Error
		}
		o.FCtl.TODO1 = ((0 | int(bs[0]&0xfc)) >> 2)
		o.FCtl.PriorityEnable = (0 | int(bs[0]&0x2)) == 0x2
		o.FCtl.TODO2 = (0 | int(bs[0]&0x1)<<16 | int(bs[1]&0xff)<<8 | int(bs[2]&0xff))
	}
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.ReadObject(&o.SeqID)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.ReadObject(&o.DFCtl)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.ReadObject(&o.SeqCount)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.ReadObject(&o.OXID)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.ReadObject(&o.RXID)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.ReadObject(&o.Parameters)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	switch o.fcType {
	case TypeELS:
		i := &els.Frame{}
		if n, err := i.ReadFrom(&_io); err != nil {
			return n, err
		}
		o.Payload = i
	}

	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	for _, f := range fixup {
		if _, err := f(); err != nil {
			return _io.Pos, err
		}
	}
	return _io.Pos, nil
}

func (o *Frame) WriteTo(w io.Writer) (int64, error) {
	_io := encoding.Writer{W: w}
	switch o.CsctlPriority.(type) {
	case CSCtl:
		o.FCtl.PriorityEnable = false
	case Prio:
		o.FCtl.PriorityEnable = true
	}

	switch o.Payload.(type) {
	case els.Frame:
		o.fcType = TypeELS
	}

	_io.WriteObject(o.RCtl)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.WriteObject(o.DestinationID)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	switch i := o.CsctlPriority.(type) {
	case *Prio:
		if n, err := i.WriteTo(&_io); err != nil {
			return n, err
		}
	case *CSCtl:
		if n, err := i.WriteTo(&_io); err != nil {
			return n, err
		}
	default:
		return _io.Pos, fmt.Errorf("Unsupported type %v", i)
	}

	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.WriteObject(o.SourceID)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.WriteObject(o.fcType)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	{
		var bs [3]byte
		bool2int := func(v bool) int {
			if v {
				return 1
			}
			return 0
		}
		bs[0] = byte(0 | (int(o.FCtl.TODO1)<<2)&0xfc | (bool2int(o.FCtl.PriorityEnable)<<1)&0x2 | ((int(o.FCtl.TODO2))>>16)&0x1)
		bs[1] = byte(0 | ((int(o.FCtl.TODO2))>>8)&0xff)
		bs[2] = byte(0 | (int(o.FCtl.TODO2))&0xff)
		_io.Write(bs[:])
	}
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.WriteObject(o.SeqID)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.WriteObject(o.DFCtl)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.WriteObject(o.SeqCount)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.WriteObject(o.OXID)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.WriteObject(o.RXID)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	_io.WriteObject(o.Parameters)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	switch i := o.Payload.(type) {
	case *els.Frame:
		if n, err := i.WriteTo(&_io); err != nil {
			return n, err
		}
	default:
		return _io.Pos, fmt.Errorf("Unsupported type %v", i)
	}

	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	return _io.Pos, nil
}

func (o *Prio) ReadFrom(r io.Reader) (int64, error) {
	_io := encoding.Reader{R: r}
	fixup := []func() (int64, error){}
	_io.ReadObject(&o.Data)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	for _, f := range fixup {
		if _, err := f(); err != nil {
			return _io.Pos, err
		}
	}
	return _io.Pos, nil
}

func (o *Prio) WriteTo(w io.Writer) (int64, error) {
	_io := encoding.Writer{W: w}
	_io.WriteObject(o.Data)
	if _io.Error != nil {
		return _io.Pos, _io.Error
	}
	return _io.Pos, nil
}

func (o *SOF) String() string {
	switch *o {
	case 0x1:
		return "SOFf <0x1> (TODO)"
	case 0x2:
		return "SOFi4 <0x2> (TODO)"
	case 0x3:
		return "SOFi2 <0x3> (TODO)"
	case 0x4:
		return "SOFi3 <0x4> (TODO)"
	case 0x5:
		return "SOFn4 <0x5> (TODO)"
	case 0x6:
		return "SOFn2 <0x6> (TODO)"
	case 0x7:
		return "SOFn3 <0x7> (TODO)"
	case 0x8:
		return "SOFc4 <0x8> (TODO)"
	default:
		return fmt.Sprintf("--Invalid Enum Value-- <0x%x>", *o)
	}
}

func (o *Type) String() string {
	switch *o {
	case 0x0:
		return "TypeBLS <0x0> (TODO)"
	case 0x1:
		return "TypeELS <0x1> (TODO)"
	case 0x4:
		return "TypeLLCSNAP <0x4> (TODO)"
	case 0x5:
		return "TypeIP <0x5> (TODO)"
	case 0x8:
		return "TypeFCP <0x8> (TODO)"
	case 0x9:
		return "TypeGPP <0x9> (TODO)"
	case 0x1b:
		return "TypeSBToCU <0x1b> (FICON / FC-SB-3: Control Unit -> Channel)"
	case 0x1c:
		return "TypeSBFromCU <0x1c> (FICON / FC-SB-3: Channel -> Control Unit)"
	case 0x20:
		return "TypeFCCT <0x20> (TODO)"
	case 0x22:
		return "TypeSWILS <0x22> (TODO)"
	case 0x23:
		return "TypeAL <0x23> (TODO)"
	case 0x24:
		return "TypeSNMP <0x24> (TODO)"
	case 0x28:
		return "TypeNVME <0x28> (TODO)"
	case 0xee:
		return "TypeSPINFAB <0xee> (TODO)"
	case 0xef:
		return "TypeDIAG <0xef> (TODO)"
	default:
		return fmt.Sprintf("--Invalid Enum Value-- <0x%x>", *o)
	}
}
